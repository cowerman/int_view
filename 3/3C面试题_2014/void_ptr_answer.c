
/*
void* 参数疑问
  关于void*在函数中传递，哪些需要强转，哪些不需要强转，疑问较多，不知如何总结void*。 问题如下：
1. http://bytes.com/topic/c/answers/919595-void-0-what-cast 
上面是关于解释void*的，由于是英文，能看懂一点点，不知最佳答案说的和我理解的是不是一样，麻烦能解释一遍他的void*优缺点么？

2.怎么解释    (*(void(*)())0)();

3.void function(void *a) {
    int tmp ;     /1
    float tmp1;   /2
    tmp = a;      /3
    a = tmp1;     /4
}
关于上面这个函数有可能是错的，可以总结的问题如下：
1).在function内部，哪些需要强转，哪些会进行隐式转换？为啥
2).在调用function时，传进的实参是否需要进行强转？

4.我在什么情况下是用void* 作为函数形参，这个优缺点是啥？

*/

#include <stdio.h>

//该函数的调用方式，可以解释你的第2个问题
void foo(void)
{
	printf("hello!\n");
}


//该函数内的代码说明，可以解释你的第3个问题
void f(void *p)
{
	printf("p = %p\n", p);
	int a = p; //这个会有警告，因为=号左的类型是整型，=号右边是指针类型，编译器无法进行隐式转换，虽然我们可以将指针的值（就是一个16进制的无符号地址值）取出来，但从语法的角度来说，不符合规范，所以有警告。但其实也仅仅只是警告，下面一行是可以打印出来的（因为p放在=号右边，是右值，用的是p里面保存的地址值，类似0x1000之类的一个值，是可以按整型来理解的，这在前面也说过）。如果真的需要将警告也消除掉，那么按照它的警告信息，我们在p的前面用(int)来进行强制类型转换就可以消除警告了。
	printf("a = %#x\n", a);
	
	float b = 1.0;
	//p = b; //=号左右类型不兼容（什么是类型兼容，例如：int *类型和void *类型，都是指针类型，所以是兼容的；而int类型和int*类型就是无法兼容的类型）。p是指针类型，只能接收指针类型的变量的值，也就是说只能接收某类型变量的地址类型的值。如果想要p保存b变量的地址，可以按下一行的方式进行
	p = (void *)&b;
}


int main(void)
{
	int *p1;
	f(p1); //第3题的第2小问，此时传递的是可以同形式参数void*类型兼容的类型，是不需要进行强制类型转换的

	int a;
	f(a); //而如果传递实际参数无法和形式参数兼容，就会有警告，如果要消除警告，需要强转，这和上面f函数里的是一样的，无需赘述。

	//foo(); //foo函数调用方式1
	//((void (*)())0x80483d4)(); //foo函数调用方式2
	//(*((void (*)())0x80483d4))(); //foo函数调用方式3

	return 0;
}

//第1个问题，关于翻译英文的，这个你应该自己解决。看不懂的英文，可以星际译王或百度。以后你会经常碰到英文的资料，这是需要你不断积累的。
//我可以告诉你大致的意思：1、可以防止直接访问结构内部成员；2、确保在对象内部和对象之间访问的一致性；3、在调用和返回时，都必须强转；4、造成命名空间污染

//第4个问题：只要实现函数的人无法知道将来使用该函数的人会传递什么类型的数据，那么都应该将函数的形式参数声明为void*
